/**
 * Product service for fetching products from the database-backed API
 * Enhanced with client-side caching for improved performance
 */

import { CacheManager, CACHE_TYPES } from '@/utils/cache';

const API_BASE_URL = pro  /**
   * Fetch available categories
   * @param {boolean} useCache - Whether to use cache (default: true)
   * @returns {Promise<Array>} Array of category names
   */
  static async fetchCategories(useCache = true) {
    // Try to get from cache first
    if (useCache && CacheManager.isAvailable()) {
      const cached = CacheManager.get(CACHE_TYPES.CATEGORIES);
      if (cached) {
        return cached;
      }
    }

    try {
      const response = await fetch(`${API_BASE_URL}/products/categories`);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      // Cache the result
      if (useCache && CacheManager.isAvailable()) {
        CacheManager.set(CACHE_TYPES.CATEGORIES, data);
      }
      
      return data;PUBLIC_API_URL || "http://localhost:5000";

export class ProductService {
  /**
   * Fetch products from the API with pagination and filtering
   * @param {Object} options - Query options
   * @param {number} options.page - Page number (default: 1)
   * @param {number} options.per_page - Items per page (default: 50)
   * @param {string} options.category - Filter by category
   * @param {string} options.split - Filter by split (train/test)
   * @param {boolean} options.useCache - Whether to use cache (default: true)
   * @returns {Promise<Object>} Products response with products array, total, page info
   */
  static async fetchProducts({ page = 1, per_page = 50, category = null, split = null, useCache = true } = {}) {
    // Generate cache key based on parameters
    const cacheKey = `page_${page}_per_${per_page}_cat_${category || 'all'}_split_${split || 'all'}`;
    
    // Try to get from cache first
    if (useCache && CacheManager.isAvailable()) {
      const cached = CacheManager.get(CACHE_TYPES.PRODUCTS, cacheKey);
      if (cached) {
        return cached;
      }
    }

    try {
      const params = new URLSearchParams();
      params.append("page", page.toString());
      params.append("per_page", per_page.toString());

      if (category) {
        params.append("category", category);
      }

      if (split) {
        params.append("split", split);
      }

      const response = await fetch(`${API_BASE_URL}/products?${params.toString()}`);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      // Cache the result
      if (useCache && CacheManager.isAvailable()) {
        CacheManager.set(CACHE_TYPES.PRODUCTS, data, cacheKey);
      }
      
      return data;
    } catch (error) {
      console.error("Error fetching products:", error);
      
      // Check if it's a network error (server not available)
      if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {
        throw new Error('Unable to connect to server. Please ensure the API server is running.');
      }
      
      throw error;
    }
  }

  /**
   * Fetch all products (with automatic pagination)
   * @param {Object} options - Query options
   * @param {string} options.category - Filter by category
   * @param {string} options.split - Filter by split (train/test)
   * @param {number} options.maxItems - Maximum items to fetch (default: 1000)
   * @param {boolean} options.useCache - Whether to use cache (default: true)
   * @returns {Promise<Array>} Array of all products
   */
  static async fetchAllProducts({ category = null, split = null, maxItems = 1000, useCache = true } = {}) {
    // Generate cache key for all products
    const cacheKey = `all_cat_${category || 'all'}_split_${split || 'all'}_max_${maxItems}`;
    
    // Try to get from cache first
    if (useCache && CacheManager.isAvailable()) {
      const cached = CacheManager.get(CACHE_TYPES.PRODUCTS, cacheKey);
      if (cached) {
        return cached;
      }
    }

    try {
      const allProducts = [];
      let page = 1;
      const per_page = 50; // Reasonable page size

      while (allProducts.length < maxItems) {
        const response = await this.fetchProducts({
          page,
          per_page,
          category,
          split,
          useCache: false, // Don't cache individual pages when fetching all
        });

        if (response.products.length === 0) {
          break; // No more products
        }

        allProducts.push(...response.products);

        // If we got less than per_page items, we've reached the end
        if (response.products.length < per_page) {
          break;
        }

        page++;
      }

      const result = allProducts.slice(0, maxItems);
      
      // Cache the complete result
      if (useCache && CacheManager.isAvailable()) {
        CacheManager.set(CACHE_TYPES.PRODUCTS, result, cacheKey);
      }
      
      return result;
    } catch (error) {
      console.error("Error fetching all products:", error);
      throw error;
    }
  }

  /**
   * Fetch best sellers products (using popular categories)
   * @param {number} limit - Number of products to fetch
   * @param {boolean} useCache - Whether to use cache (default: true)
   * @returns {Promise<Array>} Array of best seller products
   */
  static async fetchBestSellers(limit = 8, useCache = true) {
    // Try to get from cache first
    if (useCache && CacheManager.isAvailable()) {
      const cached = CacheManager.get(CACHE_TYPES.BEST_SELLERS);
      if (cached && cached.length >= limit) {
        return cached.slice(0, limit);
      }
    }

    try {
      // Get products from popular categories like "shirt", "dress", "shoes"
      const popularCategories = ["shirt", "dress", "shoes", "jacket"];
      const products = [];
      
      for (const category of popularCategories) {
        if (products.length >= limit) break;
        
        const response = await this.fetchProducts({ 
          category, 
          per_page: Math.ceil(limit / popularCategories.length),
          useCache: false // Don't cache individual category fetches
        });
        
        const convertedProducts = response.products.map(product => ({
          ...this.convertToClientProduct(product),
          isBestSeller: true,
          price: Math.round((Math.random() * 50 + 30) * 100) / 100, // Random price 30-80
        }));
        
        products.push(...convertedProducts);
      }
      
      const result = products.slice(0, limit);
      
      // Cache the result
      if (useCache && CacheManager.isAvailable()) {
        CacheManager.set(CACHE_TYPES.BEST_SELLERS, result);
      }
      
      return result;
    } catch (error) {
      console.error("Error fetching best sellers:", error);
      return [];
    }
  }

  /**
   * Fetch new arrivals products (using test split for "newer" items)
   * @param {number} limit - Number of products to fetch
   * @param {boolean} useCache - Whether to use cache (default: true)
   * @returns {Promise<Array>} Array of new arrival products
   */
  static async fetchNewArrivals(limit = 8, useCache = true) {
    // Try to get from cache first
    if (useCache && CacheManager.isAvailable()) {
      const cached = CacheManager.get(CACHE_TYPES.NEW_ARRIVALS);
      if (cached && cached.length >= limit) {
        return cached.slice(0, limit);
      }
    }
    try {
      const response = await this.fetchProducts({ 
        split: "test", // Use test split as "new arrivals"
        per_page: limit,
        useCache: false // Don't cache individual fetch
      });
      
      const products = response.products.map(product => ({
        ...this.convertToClientProduct(product),
        isNew: true,
        price: Math.round((Math.random() * 40 + 25) * 100) / 100, // Random price 25-65
      }));
      
      // Cache the result
      if (useCache && CacheManager.isAvailable()) {
        CacheManager.set(CACHE_TYPES.NEW_ARRIVALS, products);
      }
      
      return products;
    } catch (error) {
      console.error("Error fetching new arrivals:", error);
      return [];
    }
  }

  /**
   * Fetch available categories
   * @param {boolean} useCache - Whether to use cache (default: true)
   * @returns {Promise<Array>} Array of category names
   */
  static async fetchCategories(useCache = true) {
    // Try to get from cache first
    if (useCache && CacheManager.isAvailable()) {
      const cached = CacheManager.get(CACHE_TYPES.CATEGORIES);
      if (cached) {
        return cached;
      }
    }

    try {
      const response = await fetch(`${API_BASE_URL}/products/categories`);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      const categories = data.categories || [];
      
      // Cache the result
      if (useCache && CacheManager.isAvailable()) {
        CacheManager.set(CACHE_TYPES.CATEGORIES, categories);
      }
      
      return categories;
    } catch (error) {
      console.error("Error fetching categories:", error);
      return [];
    }
  }

  /**
   * Convert API product to client-side product format
   * This ensures compatibility with existing client code
   * @param {Object} apiProduct - Product from API
   * @returns {Object} Client-formatted product
   */
  static convertToClientProduct(apiProduct) {
    const metadata = apiProduct.metadata || {};

    return {
      id: apiProduct.id, // Use the UUID from database as unique ID
      name: apiProduct.name,
      filename: apiProduct.filename,
      image: apiProduct.image_url, // Use the image URL directly (now points to Supabase Storage)
      category: apiProduct.category || "general",
      subcategory: apiProduct.category || "general", // Use category as subcategory for now
      gender: "unisex", // Default since we don't have gender in our dataset
      tags: [
        apiProduct.category || "general",
        apiProduct.split || "unknown",
        ...(metadata.source ? [metadata.source] : []),
      ].filter(Boolean),
      description: `${apiProduct.category || "Item"} from ${apiProduct.split || "dataset"} dataset`,
      isNew: apiProduct.split === "train", // Mark train items as "new"
      isOnSale: false,
      isBestSeller: false,
      price: 29.99, // Default price since we don't have pricing data
      metadata: apiProduct.metadata,
    };
  }
}

export default ProductService;
